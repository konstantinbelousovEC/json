# Сборка

Проект может быть собран с помощью *cmake* ([**CMakeLists.txt**](https://github.com/konstantinbelousovEC/json/blob/main/CMakeLists.txt)) в статическую библиотеку в режимах **debug** и **release**, а также в исполняемый файл с запуском [*тестов*](https://github.com/konstantinbelousovEC/json/blob/main/tests/tests.cpp) из файла **main.cpp**.

## JSON


В файлах [*json.h*](https://github.com/konstantinbelousovEC/json/blob/main/include/json.h) и [*json.cpp*](https://github.com/konstantinbelousovEC/json/blob/main/src/json.cpp) располагается функционал парсинга JSON.

Класс [**Node**](https://github.com/konstantinbelousovEC/json/blob/27c9169b6ce3ed298d9f40e579c3278b79f291f3/include/json.h#L20) приватно наследуется от **std::variant** и хранит значения одного из следующих типов:
- Целые числа типа *int*.
- Вещественные числа типа *double*.
- Строки — тип *std::string*.
- Логический тип *bool*.
- Массивы:


    using Array = std::vector<Node>; 


- Словари:


    using Dict = std::map<std::string, Node>;
  
    
    
- *std::nullptr_t*. Используется, чтобы представить значение **null** в JSON документе. Кроме std::nullptr_t можно было бы также использовать тип *std::monostate*, однако *std::nullptr_t* кажется более подходящим по смыслу для представления **null**.

Следующие методы **Node** сообщают, хранится ли внутри значение некоторого типа:
- *bool is_int() const*;
- *bool is_double() const*; Возвращает *true*, если в **Node** хранится *int* либо *double*.
- *bool is_pure_double() const*; Возвращает *true*, если в **Node** хранится *double*.
- *bool is_bool() const*;
- *bool is_string() const*;
- *bool is_null() const*;
- *bool is_array() const*;
- *bool is_dict() const*;

Ниже перечислены методы, которые возвращают хранящееся внутри **Node** значение заданного типа. Если внутри содержится значение другого типа, должно выбрасываться исключение *std::logic_error*.
- *int as_int() const*;
- *bool as_bool() const*;
- *double as_double() const*;. Возвращает значение типа *double*, если внутри хранится *double* либо *int*. В последнем случае возвращается приведённое в *double* значение.
- *const std::string& as_string() const*;
- *const Array& as_array() const*;
- *const Map& as_dict() const*;

Объекты **Node** можно сравнивать между собой при помощи == и !=. Значения равны, если внутри них значения имеют одинаковый тип и содержимое.

При загрузке невалидных JSON-документов выбрасывается исключение *json::ParsingError*.

При загрузке и сохранении строк поддерживаются следующие escape-последовательности: \n, \r, \\", \t, \\\\.

## JSON Builder

Класс [**json::Builder**](https://github.com/konstantinbelousovEC/json/blob/27c9169b6ce3ed298d9f40e579c3278b79f291f3/include/json-builder.h#L10), позволяет сконструировать JSON-объект, используя цепочки вызовов методов. Этот класс основан на библиотеке JSON, описанной выше.

Начнём с простого примера — объекта-строки:

    json::Builder{}.value("just a string"s).build() 

Это выражение должно быть объектом **json::Node** и содержать указанную строку. Вывести построенный JSON, как и раньше, можно так:

    json::Print(
        json::Document{
            json::Builder{}
            .value("just a string"s)
            .build()
        },
        std::cout
    );
    
Вывод:

    "just a string" 
    
Более сложный пример демонстрирует все методы builder-класса на более сложном JSON-объекте:

    json::Print(
        json::Document{
                    // Форматирование не имеет формального значения:
                    // это просто цепочка вызовов методов
            json::Builder{}
            .start_dict()
                .key("key1"s).value(123)
                .key("key2"s).value("value2"s)
                .key("key3"s).start_array()
                    .value(456)
                    .start_dict().end_dict()
                    .start_dict()
                        .key(""s).value(nullptr)
                    .end_dict()
                    .value(""s)
                .end_array()
            .end_dict()
            .build()
        },
        std::cout
    ); 

Вывод:

    {
        "key1": 123,
        "key2": "value2",
        "key3": [
            456,
            {
            
            },
            {
                "": null
            },
            ""
        ]
    }

Разберём все методы класса **json::Builder**. Ниже описана их семантика, и для понимания дан контекст, в котором они вызываются.
- *key(std::string)*. При определении словаря задаёт строковое значение ключа для очередной пары ключ-значение. Следующий вызов метода обязательно должен задавать соответствующее этому ключу значение с помощью метода *value* или начинать его определение с помощью *start_dict* или *start_array*.
- *value(Node::Value)*. Задаёт значение, соответствующее ключу при определении словаря, очередной элемент массива или, если вызвать сразу после конструктора **json::Builder**, всё содержимое конструируемого JSON-объекта. Может принимать как простой объект — число или строку — так и целый массив или словарь. Здесь *Node::Value* — это синоним для базового класса *Node*, шаблона *std::variant* с набором возможных типов-значений.
- *start_dict()*. Начинает определение сложного значения-словаря. Вызывается в тех же контекстах, что и *value*. Следующим вызовом обязательно должен быть *Key* или *end_dict*.
- *start_array()*. Начинает определение сложного значения-массива. Вызывается в тех же контекстах, что и *value*. Следующим вызовом обязательно должен быть *end_array* или любой, задающий новое значение: *value*, *start_dict* или *start_array*.
- *end_dict()*. Завершает определение сложного значения-словаря. Последним незавершённым вызовом *start\** должен быть *start_dict*.
- *end_array()*. Завершает определение сложного значения-массива. Последним незавершённым вызовом *start*\* должен быть *start_array*.
- *build()*. Возвращает объект *json::Node*, содержащий JSON, описанный предыдущими вызовами методов. К этому моменту для каждого *start\** должен быть вызван соответствующий *end*\*. При этом сам объект должен быть определён, то есть вызов **json::Builder{}.build()** недопустим.
- Возвращаемое значение каждого метода, кроме *build*, должно быть *Builder&*.

##### Обработка ошибок

Методы класса имеют амортизированную линейную сложность относительно размера входных данных. Исключение — дополнительный логарифмический множитель при добавлении в словарь.

Некоторые явные ошибки обнаруживаются на этапе компиляции, а не выбрасываются в виде исключений при запуске программы.

Код **json::Builder** не должен компилироваться в следующих ситуациях:
1. Непосредственно после *key* вызван не *value*, не *start_dict* и не *start_array*.
2. После вызова *value*, последовавшего за вызовом *key*, вызван не *key* и не *end_dict*.
3. За вызовом *start_dict* следует не *key* и не *end_dict*.
4. За вызовом *start_array* следует не *value*, не *start_dict*, не *start_array* и не *end_array*.
5. После вызова *start_array* и серии *value* следует не *value*, не *start_dict*, не *start_array* и не *end_array*.

Примеры кода, которые не должны компилироваться:

    json::Builder{}.start_dict().build();  // правило 3
    json::Builder{}.start_dict().key("1"s).value(1).value(1);  // правило 2
    json::Builder{}.start_dict().key("1"s).key(""s);  // правило 1
    json::Builder{}.start_array().key("1"s);  // правило 4
    json::Builder{}.start_array().end_dict();  // правило 4
    json::Builder{}.start_array().value(1).value(2).end_dict();  // правило 5

Эта задача решается возвратом специальных вспомогательных классов, допускающих определённые наборы методов.

В случае использования методов в неверном контексте код выбросывает исключение типа *std::logic_error* с понятным сообщением об ошибке.
Это происходит в следующих ситуациях:
- Вызов некорректного метода сразу после создания **json::Builder**.
- Вызов некорректного метода после *end*\*.